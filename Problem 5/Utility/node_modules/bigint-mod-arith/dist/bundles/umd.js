!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((n="undefined"!=typeof globalThis?globalThis:n||self).bigintModArith={})}(this,(function(n){"use strict";function t(n){return n>=0?n:-n}function e(n,t){if("number"==typeof n&&(n=BigInt(n)),"number"==typeof t&&(t=BigInt(t)),n<=0n||t<=0n)throw new RangeError("a and b MUST be > 0");let e=0n,r=1n,o=1n,i=0n;for(;0n!==n;){const f=t/n,u=t%n,g=e-o*f,b=r-i*f;t=n,n=u,e=o,r=i,o=g,i=b}return{g:t,x:e,y:r}}function r(n,e){let r="number"==typeof n?BigInt(t(n)):t(n),o="number"==typeof e?BigInt(t(e)):t(e);if(0n===r)return o;if(0n===o)return r;let i=0n;for(;0n===(1n&(r|o));)r>>=1n,o>>=1n,i++;for(;0n===(1n&r);)r>>=1n;do{for(;0n===(1n&o);)o>>=1n;if(r>o){const n=r;r=o,o=n}o-=r}while(0n!==o);return r<<i}function o(n,t){if("number"==typeof n&&(n=BigInt(n)),"number"==typeof t&&(t=BigInt(t)),t<=0n)throw new RangeError("n must be > 0");const e=n%t;return e<0n?e+t:e}function i(n,t){const r=e(o(n,t),t);if(1n!==r.g)throw new RangeError(`${n.toString()} does not have inverse modulo ${t.toString()}`);return o(r.x,t)}n.abs=t,n.bitLength=function(n){if("number"==typeof n&&(n=BigInt(n)),1n===n)return 1;let t=1;do{t++}while((n>>=1n)>1n);return t},n.eGcd=e,n.gcd=r,n.lcm=function(n,e){return"number"==typeof n&&(n=BigInt(n)),"number"==typeof e&&(e=BigInt(e)),0n===n&&0n===e?BigInt(0):t(n/r(n,e)*e)},n.max=function(n,t){return n>=t?n:t},n.min=function(n,t){return n>=t?t:n},n.modInv=i,n.modPow=function n(e,r,f){if("number"==typeof e&&(e=BigInt(e)),"number"==typeof r&&(r=BigInt(r)),"number"==typeof f&&(f=BigInt(f)),f<=0n)throw new RangeError("n must be > 0");if(1n===f)return 0n;if(e=o(e,f),r<0n)return i(n(e,t(r),f),f);let u=1n;for(;r>0;)r%2n===1n&&(u=u*e%f),r/=2n,e=e**2n%f;return u},n.toZn=o}));
